using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.Audio;
using Terraria.GameContent;
using Terraria.GameContent.Bestiary;
using Terraria.GameContent.ItemDropRules;
using Terraria.ID;
using Terraria.ModLoader;
using MagnumOpus.Common.Systems;
using MagnumOpus.Common.Systems.Particles;
using MagnumOpus.Common.Systems.VFX;
using MagnumOpus.Content.EnigmaVariations.Debuffs;
using MagnumOpus.Content.EnigmaVariations.ResonanceEnergies;
using MagnumOpus.Content.EnigmaVariations.HarmonicCores;
using MagnumOpus.Content.EnigmaVariations.ResonantWeapons;

namespace MagnumOpus.Content.EnigmaVariations.Bosses
{
    /// <summary>
    /// Enigma, The Hollow Mystery - A nightmarish spider-like entity of the unknown.
    /// Features fast, aggressive ground-based combat with jumps and charges.
    /// Does NOT fly - relies on rapid movement, web attacks, and reality-warping abilities.
    /// Third boss before the final boss in the Enigma theme progression.
    /// 
    /// === PHASE SYSTEM (DoG-Inspired) ===
    /// "Curiosity" (100-60% HP): Probing, measured attacks - testing the player
    /// "Obsession" (60-30% HP): Relentless pursuit - the mystery must be solved
    /// "Void Revelation" (30-0% HP): Reality unravels - desperate unknowable assault
    /// Each phase reflects the Enigma theme's descent into madness.
    /// </summary>
    public class EnigmaTheHollowMystery : ModNPC
    {
        // Boss texture
        public override string Texture => "MagnumOpus/Content/EnigmaVariations/Bosses/EnigmaTheHollowMystery";
        
        // Enigma theme colors
        private static readonly Color EnigmaBlack = new Color(15, 10, 20);
        private static readonly Color EnigmaPurple = new Color(140, 60, 200);
        private static readonly Color EnigmaGreen = new Color(50, 220, 100);
        private static readonly Color EnigmaDeepPurple = new Color(80, 20, 120);
        
        // Phase mood system (DoG-inspired, reflecting mystery theme)
        private enum BossMood
        {
            Curiosity,      // 100-60% - Probing, testing attacks
            Obsession,      // 60-30% - Relentless pursuit
            VoidRevelation  // 30-0% - Reality unraveling
        }
        
        private BossMood currentMood = BossMood.Curiosity;
        private bool hasAnnouncedObsession = false;
        private bool hasAnnouncedVoid = false;
        
        // AI States - Spider-like ground combat
        private enum ActionState
        {
            Spawn,
            Idle,
            // Movement
            Crawling,
            JumpWindup,
            Jumping,
            Landing,
            ChargeWindup,
            Charging,
            // Attack 1 - Web Shot: Fast projectiles
            WebShotWindup,
            WebShot,
            // Attack 2 - Paradox Pounce: Rapid leap attack
            PounceWindup,
            Pouncing,
            // Attack 3 - Glyph Eruption: Ground-based AOE
            GlyphEruptionWindup,
            GlyphEruption,
            // Attack 4 - Eye Barrage: Multiple homing eyes
            EyeBarrageWindup,
            EyeBarrage,
            // Attack 5 - Void Web: Creates damaging web patterns
            VoidWebWindup,
            VoidWeb,
            // Attack 6 - Reality Quake: Ground slam with shockwaves
            RealityQuakeWindup,
            RealityQuake,
            // Attack 7 - Enigma Swarm: Spawns mini spiders
            SwarmWindup,
            Swarm,
            // Attack 8 - Mystery Vortex: Pulls player while attacking
            VortexWindup,
            Vortex,
            // === ANTI-AIR ATTACKS - Punish hovering players ===
            // Attack 9 - Ceiling Web: Spawns web ceiling that falls down
            CeilingWebWindup,
            CeilingWeb,
            // Attack 10 - Sky Eye Rain: Eyes rain from above
            SkyEyeRainWindup,
            SkyEyeRain,
            // Attack 11 - Reality Leap: Teleport to player's height and attack
            RealityLeapWindup,
            RealityLeap,
            // Attack 12 - Glyph Pillars: Rising glyphs that reach the sky
            GlyphPillarsWindup,
            GlyphPillars,
            // Death
            Dying
        }

        private ActionState State
        {
            get => (ActionState)NPC.ai[0];
            set => NPC.ai[0] = (float)value;
        }

        private float Timer
        {
            get => NPC.ai[1];
            set => NPC.ai[1] = value;
        }

        private float AttackPhase
        {
            get => NPC.ai[2];
            set => NPC.ai[2] = value;
        }

        private float AttackCooldown
        {
            get => NPC.ai[3];
            set => NPC.ai[3] = value;
        }

        // Movement
        private bool isGrounded = false;
        private float crawlDirection = 1f;
        private float crawlSpeed = 6f; // Fast crawler
        private int jumpCooldown = 0;
        private const int JumpCooldownMax = 120; // 2 seconds between jumps
        private int attacksSinceLastJump = 0;
        private Vector2 chargeTarget = Vector2.Zero;
        private float chargeSpeed = 25f;
        
        // === ANTI-AIR TRACKING ===
        private int playerAboveTimer = 0;           // How long player has been above
        private const int AntiAirThreshold = 60;    // 1 second before triggering anti-air
        private const float AntiAirHeightThreshold = 200f; // Height difference to trigger
        private int antiAirAttackCooldown = 0;
        private Vector2 lastPlayerGroundPos = Vector2.Zero; // Track where player lands
        
        // Visual effects
        private float auraPulse = 0f;
        private float distortionIntensity = 0f;
        private float eyeGlowIntensity = 0f;
        private bool hasActivatedSky = false;
        
        // Animation - Single PNG (no spritesheet)
        private int frameCounter = 0;
        private int currentFrame = 0;
        private const int TotalFrames = 1;
        private const int FrameColumns = 1;
        private const int FrameRows = 1;
        private const int FrameSpeed = 5;
        
        // Health bar registration
        private bool hasRegisteredHealthBar = false;
        
        // Death animation
        private int deathTimer = 0;
        private const int DeathAnimationDuration = 480; // 8 seconds death
        private float deathFlashIntensity = 0f;
        
        // Attack tracking
        private int consecutiveAttacks = 0;
        private int lastAttackType = -1;
        private bool isEnraged = false;
        private int enrageTimer = 0;
        
        // Pounce tracking
        private Vector2 pounceTarget = Vector2.Zero;
        private int pounceCount = 0;

        public override void SetStaticDefaults()
        {
            Main.npcFrameCount[Type] = 1; // Handle 6x6 manually
            
            NPCID.Sets.MPAllowedEnemies[Type] = true;
            NPCID.Sets.BossBestiaryPriority.Add(Type);
            NPCID.Sets.TrailCacheLength[Type] = 10;
            NPCID.Sets.TrailingMode[Type] = 1;
            NPCID.Sets.MustAlwaysDraw[Type] = true;
            
            // Debuff immunities
            NPCID.Sets.SpecificDebuffImmunity[Type][BuffID.Poisoned] = true;
            NPCID.Sets.SpecificDebuffImmunity[Type][BuffID.Confused] = true;
            NPCID.Sets.SpecificDebuffImmunity[Type][BuffID.OnFire] = true;
            NPCID.Sets.SpecificDebuffImmunity[Type][BuffID.Venom] = true;
            NPCID.Sets.SpecificDebuffImmunity[Type][BuffID.Webbed] = true;
        }

        public override void SetDefaults()
        {
            NPC.width = 200;
            NPC.height = 140;
            NPC.damage = 160; // High damage for aggressive boss
            NPC.defense = 90;
            NPC.lifeMax = 800000; // 800k HP - Third tier before final
            NPC.HitSound = SoundID.NPCHit8 with { Pitch = -0.4f };
            NPC.DeathSound = SoundID.NPCDeath10;
            NPC.knockBackResist = 0f;
            NPC.noGravity = false; // Ground-based!
            NPC.noTileCollide = false; // Collides with tiles!
            NPC.value = Item.buyPrice(gold: 35);
            NPC.boss = true;
            NPC.npcSlots = 16f;
            NPC.aiStyle = -1;
            NPC.scale = 1.1f;
            
            // Visual offset - raised significantly to prevent sinking into ground
            DrawOffsetY = -130f;
            
            Music = MusicID.Boss3; // Fallback until custom music
        }

        public override void SetBestiary(BestiaryDatabase database, BestiaryEntry bestiaryEntry)
        {
            bestiaryEntry.Info.AddRange(new IBestiaryInfoElement[]
            {
                BestiaryDatabaseNPCsPopulator.CommonTags.SpawnConditions.Biomes.Underground,
                new FlavorTextBestiaryInfoElement("Enigma, The Hollow Mystery - " +
                    "A spider-like abomination that embodies the unknowable void. " +
                    "Its many eyes see through dimensions, and its legs pierce reality itself.")
            });
        }

        public override void AI()
        {
            // Register with health bar system
            if (!hasRegisteredHealthBar)
            {
                BossHealthBarUI.RegisterBoss(NPC, BossColorTheme.Enigma);
                hasRegisteredHealthBar = true;
            }
            
            NPC.TargetClosest(true);
            Player target = Main.player[NPC.target];
            
            // Ground check
            CheckGrounded();
            
            // Handle dying
            if (State == ActionState.Dying)
            {
                UpdateDeathAnimation(target);
                return;
            }
            
            // Despawn check
            if (!target.active || target.dead)
            {
                NPC.velocity.Y += 0.3f;
                NPC.EncourageDespawn(60);
                return;
            }
            
            // Update timers
            Timer++;
            auraPulse += 0.05f;
            jumpCooldown = Math.Max(0, jumpCooldown - 1);
            AttackCooldown = Math.Max(0, AttackCooldown - 1);
            antiAirAttackCooldown = Math.Max(0, antiAirAttackCooldown - 1);
            
            // === ANTI-AIR DETECTION - Punish hovering players ===
            float heightDiff = NPC.Center.Y - target.Center.Y;
            if (heightDiff > AntiAirHeightThreshold && !Collision.SolidCollision(target.position, target.width, target.height + 32))
            {
                // Player is significantly above us and not on a platform
                playerAboveTimer++;
                
                // Spawn warning particles when player hovers too long
                if (playerAboveTimer > AntiAirThreshold / 2 && playerAboveTimer % 8 == 0)
                {
                    // Eyes look up at hovering player menacingly
                    Vector2 lookDir = (target.Center - NPC.Center).SafeNormalize(Vector2.UnitY);
                    CustomParticles.EnigmaEyeGaze(NPC.Center + new Vector2(0, -40), EnigmaGreen * 1.2f, 0.6f, lookDir);
                    
                    // Warning glyphs appear
                    CustomParticles.Glyph(target.Center + Main.rand.NextVector2Circular(50, 50), EnigmaPurple * 0.7f, 0.4f, -1);
                }
            }
            else
            {
                playerAboveTimer = Math.Max(0, playerAboveTimer - 2); // Decay when player is grounded
                if (playerAboveTimer == 0)
                    lastPlayerGroundPos = target.Center; // Track last ground position
            }
            
            // === MOOD SYSTEM (DoG-Inspired) ===
            // Updates phase mood based on health with reality-distorting transitions
            UpdateMood(target);
            
            // Enrage at 30% health
            if (!isEnraged && NPC.life < NPC.lifeMax * 0.3f)
            {
                isEnraged = true;
                EnrageTransition();
            }
            
            // Update enrage effects
            if (isEnraged)
            {
                enrageTimer++;
                crawlSpeed = 9f;
                chargeSpeed = 35f;
            }
            
            // Eye glow intensity
            eyeGlowIntensity = 0.6f + (float)Math.Sin(auraPulse * 2f) * 0.4f;
            if (isEnraged) eyeGlowIntensity *= 1.5f;
            
            // Ambient lighting
            float pulse = 0.5f + (float)Math.Sin(auraPulse) * 0.3f;
            Lighting.AddLight(NPC.Center, EnigmaPurple.ToVector3() * pulse);
            Lighting.AddLight(NPC.Center + new Vector2(0, -30), EnigmaGreen.ToVector3() * eyeGlowIntensity * 0.5f);
            
            // Spawn ambient particles
            SpawnAmbientParticles();
            
            // State machine
            switch (State)
            {
                case ActionState.Spawn:
                    SpawnSequence(target);
                    break;
                case ActionState.Idle:
                    IdleBehavior(target);
                    break;
                case ActionState.Crawling:
                    CrawlingBehavior(target);
                    break;
                case ActionState.JumpWindup:
                    JumpWindupBehavior(target);
                    break;
                case ActionState.Jumping:
                    JumpingBehavior(target);
                    break;
                case ActionState.Landing:
                    LandingBehavior(target);
                    break;
                case ActionState.ChargeWindup:
                    ChargeWindupBehavior(target);
                    break;
                case ActionState.Charging:
                    ChargingBehavior(target);
                    break;
                    
                // Attacks
                case ActionState.WebShotWindup:
                    WebShotWindup(target);
                    break;
                case ActionState.WebShot:
                    WebShotAttack(target);
                    break;
                case ActionState.PounceWindup:
                    PounceWindup(target);
                    break;
                case ActionState.Pouncing:
                    PounceAttack(target);
                    break;
                case ActionState.GlyphEruptionWindup:
                    GlyphEruptionWindup(target);
                    break;
                case ActionState.GlyphEruption:
                    GlyphEruptionAttack(target);
                    break;
                case ActionState.EyeBarrageWindup:
                    EyeBarrageWindup(target);
                    break;
                case ActionState.EyeBarrage:
                    EyeBarrageAttack(target);
                    break;
                case ActionState.VoidWebWindup:
                    VoidWebWindup(target);
                    break;
                case ActionState.VoidWeb:
                    VoidWebAttack(target);
                    break;
                case ActionState.RealityQuakeWindup:
                    RealityQuakeWindup(target);
                    break;
                case ActionState.RealityQuake:
                    RealityQuakeAttack(target);
                    break;
                case ActionState.SwarmWindup:
                    SwarmWindup(target);
                    break;
                case ActionState.Swarm:
                    SwarmAttack(target);
                    break;
                case ActionState.VortexWindup:
                    VortexWindup(target);
                    break;
                case ActionState.Vortex:
                    VortexAttack(target);
                    break;
                // === ANTI-AIR ATTACKS ===
                case ActionState.CeilingWebWindup:
                    CeilingWebWindup(target);
                    break;
                case ActionState.CeilingWeb:
                    CeilingWebAttack(target);
                    break;
                case ActionState.SkyEyeRainWindup:
                    SkyEyeRainWindup(target);
                    break;
                case ActionState.SkyEyeRain:
                    SkyEyeRainAttack(target);
                    break;
                case ActionState.RealityLeapWindup:
                    RealityLeapWindup(target);
                    break;
                case ActionState.RealityLeap:
                    RealityLeapAttack(target);
                    break;
                case ActionState.GlyphPillarsWindup:
                    GlyphPillarsWindup(target);
                    break;
                case ActionState.GlyphPillars:
                    GlyphPillarsAttack(target);
                    break;
            }
            
            // Face target during movement
            if (State == ActionState.Crawling || State == ActionState.Idle)
            {
                NPC.spriteDirection = NPC.direction = (target.Center.X > NPC.Center.X) ? 1 : -1;
            }
        }
        
        private void CheckGrounded()
        {
            Vector2 bottomLeft = new Vector2(NPC.position.X + 20, NPC.position.Y + NPC.height + 4);
            Vector2 bottomRight = new Vector2(NPC.position.X + NPC.width - 20, NPC.position.Y + NPC.height + 4);
            
            Point tileLeft = bottomLeft.ToTileCoordinates();
            Point tileRight = bottomRight.ToTileCoordinates();
            
            bool leftSolid = WorldGen.SolidTile(tileLeft.X, tileLeft.Y);
            bool rightSolid = WorldGen.SolidTile(tileRight.X, tileRight.Y);
            
            isGrounded = (leftSolid || rightSolid) && NPC.velocity.Y >= 0;
        }
        
        private void SpawnAmbientParticles()
        {
            // === ENIGMA AMBIENT EFFECTS ===
            // A symphony of the unknowable - watching eyes, reality glitches, void tendrils, and cosmic uncertainty
            
            float moodIntensity = GetMoodIntensity();
            float mysteryPulse = (float)Math.Sin(Main.GameUpdateCount * 0.04f) * 0.3f + 0.7f;
            float voidRipple = (float)Math.Sin(Main.GameUpdateCount * 0.025f);
            
            // === 1. WATCHING EYE CONSTELLATION ===
            // Eyes orbit and watch from the void, always observing
            int eyeCount = 3 + (int)(moodIntensity * 3);
            for (int i = 0; i < eyeCount; i++)
            {
                float eyeAngle = Main.GameUpdateCount * 0.012f + (MathHelper.TwoPi * i / eyeCount);
                float eyeRadius = 90f + (float)Math.Sin(eyeAngle * 2f + i) * 25f;
                
                Vector2 eyePos = NPC.Center + new Vector2(
                    (float)Math.Cos(eyeAngle) * eyeRadius,
                    (float)Math.Sin(eyeAngle) * eyeRadius * 0.5f);
                
                // Eyes spawn periodically and fade - always watching inward
                if ((Main.GameUpdateCount + i * 13) % 40 == 0)
                {
                    Vector2 lookDir = (NPC.Center - eyePos).SafeNormalize(Vector2.Zero);
                    Color eyeColor = Color.Lerp(EnigmaPurple, EnigmaGreen, (float)i / eyeCount) * mysteryPulse;
                    CustomParticles.EnigmaEyeGaze(eyePos, eyeColor * 0.6f, 0.2f + moodIntensity * 0.1f, lookDir);
                }
            }
            
            // === 2. GLYPH ORBIT SYSTEM ===
            // Ancient glyphs orbit in a magical circle
            int glyphCount = 6 + (int)(moodIntensity * 4);
            float glyphOrbitRadius = 75f + voidRipple * 15f;
            
            for (int i = 0; i < glyphCount; i++)
            {
                // Counter-rotation for unsettling effect
                float glyphAngle = -Main.GameUpdateCount * 0.015f + (MathHelper.TwoPi * i / glyphCount);
                Vector2 glyphPos = NPC.Center + glyphAngle.ToRotationVector2() * glyphOrbitRadius;
                
                if ((Main.GameUpdateCount + i * 7) % 15 == 0)
                {
                    Color glyphColor = Color.Lerp(EnigmaPurple, EnigmaGreen, 
                        (float)Math.Sin(Main.GameUpdateCount * 0.05f + i) * 0.5f + 0.5f);
                    CustomParticles.Glyph(glyphPos, glyphColor * 0.5f * mysteryPulse, 0.25f);
                }
            }
            
            // === 3. VOID CORRUPTION TENDRILS ===
            // Dark tendrils reach out from the boss, spreading mystery
            if (Main.rand.NextBool(4))
            {
                float tendrilAngle = Main.rand.NextFloat(MathHelper.TwoPi);
                float tendrilLength = 50f + moodIntensity * 40f;
                
                // Draw particles along the tendril path
                for (int j = 0; j < 4; j++)
                {
                    float progress = j / 4f;
                    Vector2 tendrilPos = NPC.Center + tendrilAngle.ToRotationVector2() * tendrilLength * progress;
                    Vector2 tendrilVel = tendrilAngle.ToRotationVector2() * 1.5f + Main.rand.NextVector2Circular(0.5f, 0.5f);
                    
                    Color tendrilColor = Color.Lerp(EnigmaBlack, EnigmaPurple, progress) * (1f - progress * 0.4f);
                    
                    var tendril = new GenericGlowParticle(tendrilPos, tendrilVel, tendrilColor * 0.6f, 
                        0.25f - progress * 0.1f, Main.rand.Next(20, 35), true);
                    MagnumParticleHandler.SpawnParticle(tendril);
                }
            }
            
            // === 4. REALITY GLITCH FLICKERS ===
            // Brief flickers of wrongness - reality questioning itself
            if (Main.rand.NextBool((int)(12 - moodIntensity * 6)))
            {
                Vector2 glitchPos = NPC.Center + Main.rand.NextVector2Circular(120f, 80f);
                
                // Random color flash - purple, green, or inverted
                Color glitchColor = Main.rand.Next(3) switch
                {
                    0 => EnigmaPurple,
                    1 => EnigmaGreen,
                    _ => Color.White // Brief white flash for "glitch"
                };
                
                CustomParticles.GenericFlare(glitchPos, glitchColor * 0.7f, 0.3f + Main.rand.NextFloat(0.2f), 
                    Main.rand.Next(5, 12));
            }
            
            // === 5. VOID MIST - CREEPING DARKNESS ===
            // Dark mist creeps along the ground and rises slowly
            if (Main.rand.NextBool(4))
            {
                Vector2 mistPos = NPC.Center + new Vector2(
                    Main.rand.NextFloat(-100f, 100f),
                    Main.rand.NextFloat(20f, 50f));
                
                Vector2 mistVel = new Vector2(voidRipple * 0.4f, Main.rand.NextFloat(-0.8f, -0.2f));
                Color mistColor = Color.Lerp(EnigmaBlack, EnigmaPurple, 0.3f) * 0.4f;
                
                var mist = new HeavySmokeParticle(mistPos, mistVel, mistColor, Main.rand.Next(50, 80), 
                    Main.rand.NextFloat(0.3f, 0.5f), 0.5f, 0.01f, false);
                MagnumParticleHandler.SpawnParticle(mist);
            }
            
            // === 6. SPIDER LEG TRAIL EFFECTS ===
            // Trail particles from the spider legs during movement
            if ((State == ActionState.Crawling || State == ActionState.Charging) && Main.rand.NextBool(2))
            {
                for (int leg = 0; leg < 4; leg++)
                {
                    float legAngle = MathHelper.PiOver4 + leg * MathHelper.PiOver2;
                    Vector2 legPos = NPC.Center + new Vector2((leg < 2 ? -1 : 1) * 70, 35);
                    
                    // Void particles left behind by legs
                    Color legTrail = Color.Lerp(EnigmaBlack, EnigmaPurple, Main.rand.NextFloat(0.4f));
                    var legSmoke = new HeavySmokeParticle(legPos, Vector2.UnitY * -0.5f, 
                        legTrail, Main.rand.Next(15, 25), 0.2f, 0.35f, 0.025f, false);
                    MagnumParticleHandler.SpawnParticle(legSmoke);
                }
            }
            
            // === 7. QUESTIONING MARKS - MYSTERY PARTICLES ===
            // Faint "?" like shapes form in the air around the boss
            if (Main.rand.NextBool(20))
            {
                Vector2 questionPos = NPC.Center + Main.rand.NextVector2Circular(80f, 60f);
                // Use glyph particle for mysterious symbol
                CustomParticles.Glyph(questionPos, EnigmaGreen * 0.4f, 0.3f);
            }
            
            // === 8. MOOD-SPECIFIC INTENSIFIERS ===
            switch (currentMood)
            {
                case BossMood.Curiosity:
                    // Gentle watching - the mystery observes
                    if (Main.rand.NextBool(15))
                    {
                        Vector2 curiousEye = NPC.Center + Main.rand.NextVector2Circular(100f, 70f);
                        CustomParticles.EnigmaEyeGaze(curiousEye, EnigmaGreen * 0.4f, 0.15f);
                    }
                    break;
                    
                case BossMood.Obsession:
                    // More intense - the mystery fixates
                    if (Main.rand.NextBool(6))
                    {
                        Vector2 obsessPos = NPC.Center + Main.rand.NextVector2Circular(70f, 50f);
                        CustomParticles.GenericFlare(obsessPos, EnigmaPurple * 0.6f, 0.35f, 10);
                    }
                    // More frequent eyes
                    if (Main.rand.NextBool(10))
                    {
                        Vector2 watchPos = NPC.Center + Main.rand.NextVector2Circular(90f, 70f);
                        Vector2 watchDir = (Main.LocalPlayer.Center - watchPos).SafeNormalize(Vector2.Zero);
                        CustomParticles.EnigmaEyeGaze(watchPos, EnigmaGreen * 0.5f, 0.2f, watchDir);
                    }
                    break;
                    
                case BossMood.VoidRevelation:
                    // Maximum eldritch - the void reveals itself
                    if (Main.rand.NextBool(3))
                    {
                        // Heavy void particles
                        Vector2 voidPos = NPC.Center + Main.rand.NextVector2Circular(100f, 80f);
                        CustomParticles.GenericFlare(voidPos, EnigmaPurple, 0.4f, 8);
                    }
                    
                    // Eyes watching everywhere
                    if (Main.rand.NextBool(5))
                    {
                        Vector2 revealEye = NPC.Center + Main.rand.NextVector2Circular(120f, 90f);
                        Vector2 revealDir = Main.rand.NextVector2Unit();
                        CustomParticles.EnigmaEyeGaze(revealEye, EnigmaGreen * 0.7f, 0.25f, revealDir);
                    }
                    
                    // Glyph bursts
                    if (Main.rand.NextBool(8))
                    {
                        CustomParticles.GlyphBurst(NPC.Center + Main.rand.NextVector2Circular(50f, 50f), 
                            EnigmaPurple * 0.5f, 4, 3f);
                    }
                    break;
            }
            
            // === 9. PULSING VOID CORE ===
            // The center of the enigma pulses with otherworldly energy
            if (Main.GameUpdateCount % 4 == 0)
            {
                Color coreColor = Color.Lerp(EnigmaPurple, EnigmaGreen, mysteryPulse);
                CustomParticles.GenericFlare(NPC.Center, coreColor * 0.4f * mysteryPulse, 0.5f, 8);
            }
            
            // === 10. DYNAMIC LIGHTING ===
            // Eerie, pulsing light that shifts between purple and green
            float colorShift = (float)Math.Sin(Main.GameUpdateCount * 0.03f) * 0.5f + 0.5f;
            Vector3 enigmaLight = Vector3.Lerp(
                EnigmaPurple.ToVector3(),  // Purple
                EnigmaGreen.ToVector3(),   // Green
                colorShift) * mysteryPulse;
            
            Lighting.AddLight(NPC.Center, enigmaLight * (0.6f + moodIntensity * 0.4f));
        }
        
        private float GetMoodIntensity()
        {
            return currentMood switch
            {
                BossMood.Curiosity => 0.3f,
                BossMood.Obsession => 0.6f,
                BossMood.VoidRevelation => 1.0f,
                _ => 0.3f
            };
        }
        
        private void EnrageTransition()
        {
            // Dramatic enrage announcement
            Main.NewText("The Hollow Mystery reveals its true form!", EnigmaGreen);
            SoundEngine.PlaySound(SoundID.Roar, NPC.Center);
            
            // Screen shake for boss
            EroicaScreenShake.LargeShake(NPC.Center);
            
            // Massive particle burst
            UnifiedVFX.EnigmaVariations.Explosion(NPC.Center, 2.5f);
            
            // Eye explosion
            CustomParticles.EnigmaEyeExplosion(NPC.Center, EnigmaGreen, 12, 8f);
            CustomParticles.GlyphBurst(NPC.Center, EnigmaPurple, 10, 6f);
            
            // Reality distortion
            FateRealityDistortion.TriggerChromaticAberration(NPC.Center, 8f, 30);
        }
        
        #region Movement States
        
        private void SpawnSequence(Player target)
        {
            if (Timer == 1)
            {
                Main.NewText("Something watches from the shadows...", EnigmaPurple);
                SoundEngine.PlaySound(SoundID.Zombie105 with { Pitch = -0.5f, Volume = 1.2f }, NPC.Center);
                
                // Spawn VFX
                CustomParticles.EnigmaEyeFormation(NPC.Center, EnigmaGreen, 8, 100f);
                UnifiedVFX.EnigmaVariations.Impact(NPC.Center, 1.5f);
            }
            
            // Build-up particles
            if (Timer % 8 == 0)
            {
                ThemedParticles.EnigmaImpact(NPC.Center + Main.rand.NextVector2Circular(60, 40), 1f);
            }
            
            NPC.velocity.X = 0;
            
            if (Timer >= 90)
            {
                Main.NewText("Enigma, The Hollow Mystery emerges!", EnigmaGreen);
                EroicaScreenShake.MediumShake(NPC.Center);
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        /// <summary>
        /// Updates the current mood based on health thresholds with reality-distorting transitions.
        /// Reflects the Enigma theme's descent into unknowable madness.
        /// </summary>
        private void UpdateMood(Player target)
        {
            float healthPercent = (float)NPC.life / NPC.lifeMax;
            
            // Transition to Obsession at 60% HP
            if (healthPercent <= 0.6f && !hasAnnouncedObsession)
            {
                hasAnnouncedObsession = true;
                currentMood = BossMood.Obsession;
                AnnounceMoodTransition("Obsession", target);
            }
            // Transition to Void Revelation at 30% HP
            else if (healthPercent <= 0.3f && !hasAnnouncedVoid)
            {
                hasAnnouncedVoid = true;
                currentMood = BossMood.VoidRevelation;
                AnnounceMoodTransition("VoidRevelation", target);
            }
        }
        
        /// <summary>
        /// Creates dramatic VFX announcement when transitioning between moods.
        /// Mysterious, reality-warping transitions befitting the Enigma theme.
        /// </summary>
        private void AnnounceMoodTransition(string moodName, Player target)
        {
            bool isVoid = moodName == "VoidRevelation";
            
            // Screen shake - reality shudders
            if (target.active)
            {
                MagnumScreenEffects.AddScreenShake(isVoid ? 22f : 14f);
            }
            
            // Eerie sound - otherworldly echo
            SoundEngine.PlaySound(SoundID.NPCDeath6 with { Pitch = isVoid ? -0.6f : -0.3f, Volume = 1.4f }, NPC.Center);
            SoundEngine.PlaySound(SoundID.Item29 with { Pitch = isVoid ? 0.3f : 0f, Volume = 1f }, NPC.Center);
            
            // Reality distortion effect
            UnifiedVFX.EnigmaVariations.DeathExplosion(NPC.Center, isVoid ? 2.5f : 1.8f);
            
            // Glyph explosion - arcane symbols scatter
            int glyphCount = isVoid ? 16 : 10;
            CustomParticles.GlyphBurst(NPC.Center, EnigmaPurple, glyphCount, 8f);
            
            // Enigma eyes manifest - watching from the void
            for (int i = 0; i < (isVoid ? 8 : 5); i++)
            {
                float angle = MathHelper.TwoPi * i / (isVoid ? 8 : 5);
                Vector2 eyePos = NPC.Center + angle.ToRotationVector2() * 80f;
                Vector2 lookDir = -angle.ToRotationVector2(); // Look inward
                CustomParticles.EnigmaEyeGaze(eyePos, EnigmaGreen, 0.6f, lookDir);
            }
            
            // Expanding void halos
            for (int ring = 0; ring < 6; ring++)
            {
                float progress = ring / 6f;
                Color ringColor = Color.Lerp(EnigmaPurple, EnigmaGreen, progress);
                CustomParticles.HaloRing(NPC.Center, ringColor, 0.4f + ring * 0.3f, 22 + ring * 4);
            }
            
            // Mystery particles swirl
            for (int i = 0; i < 20; i++)
            {
                float angle = MathHelper.TwoPi * i / 20f + auraPulse;
                Vector2 particlePos = NPC.Center + angle.ToRotationVector2() * Main.rand.NextFloat(40f, 100f);
                Color particleColor = Color.Lerp(EnigmaBlack, Main.rand.NextBool() ? EnigmaPurple : EnigmaGreen, 0.5f);
                CustomParticles.GenericFlare(particlePos, particleColor, 0.4f, 25);
            }
            
            // Update movement parameters based on mood
            crawlSpeed = currentMood switch
            {
                BossMood.Curiosity => 6f,
                BossMood.Obsession => 9f,
                BossMood.VoidRevelation => 12f,
                _ => 6f
            };
            
            chargeSpeed = currentMood switch
            {
                BossMood.Curiosity => 25f,
                BossMood.Obsession => 32f,
                BossMood.VoidRevelation => 40f,
                _ => 25f
            };
            
            // Text announcement
            if (Main.netMode != NetmodeID.Server)
            {
                string text = isVoid ? "THE VOID REVEALS..." : "OBSESSION CONSUMES!";
                Color textColor = isVoid ? EnigmaGreen : EnigmaPurple;
                CombatText.NewText(NPC.Hitbox, textColor, text, true);
            }
        }
        
        /// <summary>
        /// Gets attack cooldown based on current mood - deeper mystery means faster attacks.
        /// AGGRESSIVE PACING - minimal downtime between attacks.
        /// </summary>
        private int GetMoodAttackCooldown()
        {
            return currentMood switch
            {
                BossMood.Curiosity => 35,       // Measured probing - still threatening
                BossMood.Obsession => 22,      // Relentless pursuit - barely time to breathe
                BossMood.VoidRevelation => 12, // Reality unraveling - non-stop assault
                _ => 35
            };
        }
        
        private void IdleBehavior(Player target)
        {
            // Brief idle before selecting next action - AGGRESSIVE, minimal wait
            if (isGrounded)
                NPC.velocity.X *= 0.9f;
            
            // Enraged = immediate action, Normal = quick transition
            if (Timer >= (isEnraged ? 10 : 20))
            {
                SelectNextAction(target);
            }
        }
        
        private void CrawlingBehavior(Player target)
        {
            float direction = Math.Sign(target.Center.X - NPC.Center.X);
            crawlDirection = direction;
            
            // Mood-based movement parameters
            float moodCrawlSpeed = currentMood switch
            {
                BossMood.Curiosity => 6f,
                BossMood.Obsession => 9f,
                BossMood.VoidRevelation => 12f,
                _ => 6f
            };
            
            float moodLerpFactor = currentMood switch
            {
                BossMood.Curiosity => 0.12f,
                BossMood.Obsession => 0.18f,
                BossMood.VoidRevelation => 0.25f,
                _ => 0.12f
            };
            
            if (isGrounded)
            {
                // Mood-based crawl with smooth interpolation
                float currentCrawlSpeed = isEnraged ? moodCrawlSpeed * 1.3f : moodCrawlSpeed;
                NPC.velocity.X = MathHelper.Lerp(NPC.velocity.X, direction * currentCrawlSpeed, moodLerpFactor);
                
                // Crawling particles - more intense in later moods
                int particleInterval = currentMood switch
                {
                    BossMood.Curiosity => 8,
                    BossMood.Obsession => 5,
                    BossMood.VoidRevelation => 3,
                    _ => 8
                };
                
                if (Timer % particleInterval == 0)
                {
                    // Trail particles
                    Color trailColor = Color.Lerp(EnigmaPurple, EnigmaGreen, Main.rand.NextFloat());
                    CustomParticles.GenericGlow(NPC.Bottom + Main.rand.NextVector2Circular(20f, 5f), trailColor * 0.5f, 0.25f, 15);
                    
                    // Extra void particles in VoidRevelation
                    if (currentMood == BossMood.VoidRevelation)
                    {
                        CustomParticles.Glyph(NPC.Center + Main.rand.NextVector2Circular(40f, 40f), EnigmaGreen * 0.6f, 0.3f, -1);
                    }
                }
            }
            
            // Check for jump opportunity - mood affects thresholds
            float heightDiff = target.Center.Y - NPC.Center.Y;
            float distanceX = Math.Abs(target.Center.X - NPC.Center.X);
            
            float jumpHeightThreshold = currentMood switch
            {
                BossMood.Curiosity => -120,
                BossMood.Obsession => -100,
                BossMood.VoidRevelation => -80,
                _ => -120
            };
            
            float jumpDistanceThreshold = currentMood switch
            {
                BossMood.Curiosity => 450,
                BossMood.Obsession => 380,
                BossMood.VoidRevelation => 300,
                _ => 450
            };
            
            // Jump if player is above or far away
            if (jumpCooldown <= 0 && isGrounded && (heightDiff < jumpHeightThreshold || distanceX > jumpDistanceThreshold))
            {
                State = ActionState.JumpWindup;
                Timer = 0;
                return;
            }
            
            // Select attack - use mood-based cooldown
            int attackWindow = GetMoodAttackCooldown();
            if (Timer >= attackWindow && AttackCooldown <= 0)
            {
                SelectNextAction(target);
            }
        }
        
        private void JumpWindupBehavior(Player target)
        {
            // Crouch before jump
            NPC.velocity.X *= 0.95f;
            
            // Build-up particles
            if (Timer % 5 == 0)
            {
                CustomParticles.GenericFlare(NPC.Bottom, EnigmaPurple, 0.4f + Timer * 0.01f, 15);
                CustomParticles.GlyphBurst(NPC.Bottom, EnigmaGreen, 2, 2f);
            }
            
            if (Timer >= 25)
            {
                // Execute jump
                Vector2 toTarget = target.Center - NPC.Center;
                float jumpPower = MathHelper.Clamp(Math.Abs(toTarget.Y) * 0.02f + 15f, 15f, 28f);
                float horizontalPower = MathHelper.Clamp(toTarget.X * 0.015f, -12f, 12f);
                
                NPC.velocity = new Vector2(horizontalPower, -jumpPower);
                
                // Jump VFX
                EroicaScreenShake.SmallShake(NPC.Center);
                UnifiedVFX.EnigmaVariations.Impact(NPC.Bottom, 1f);
                SoundEngine.PlaySound(SoundID.Item24 with { Pitch = -0.3f }, NPC.Center);
                
                jumpCooldown = JumpCooldownMax;
                State = ActionState.Jumping;
                Timer = 0;
            }
        }
        
        private void JumpingBehavior(Player target)
        {
            // Air control
            float direction = Math.Sign(target.Center.X - NPC.Center.X);
            NPC.velocity.X += direction * 0.2f;
            NPC.velocity.X = MathHelper.Clamp(NPC.velocity.X, -15f, 15f);
            
            // Jump trail
            if (Timer % 3 == 0)
            {
                Color trailColor = Color.Lerp(EnigmaPurple, EnigmaGreen, Main.rand.NextFloat());
                CustomParticles.GenericGlow(NPC.Center, trailColor * 0.6f, 0.4f, 20);
            }
            
            // Check for landing
            if (isGrounded && Timer > 10)
            {
                State = ActionState.Landing;
                Timer = 0;
            }
        }
        
        private void LandingBehavior(Player target)
        {
            NPC.velocity.X *= 0.85f;
            
            if (Timer == 1)
            {
                // Landing impact
                EroicaScreenShake.SmallShake(NPC.Center);
                UnifiedVFX.EnigmaVariations.Impact(NPC.Bottom, 0.8f);
                SoundEngine.PlaySound(SoundID.Item14 with { Pitch = 0.2f, Volume = 0.7f }, NPC.Center);
                
                // Ground crack particles
                for (int i = 0; i < 8; i++)
                {
                    float angle = MathHelper.Pi + MathHelper.PiOver4 * (i - 3.5f) * 0.3f;
                    Vector2 vel = angle.ToRotationVector2() * Main.rand.NextFloat(3f, 6f);
                    CustomParticles.GenericGlow(NPC.Bottom + vel, EnigmaPurple, 0.3f, 25);
                }
            }
            
            if (Timer >= 15)
            {
                attacksSinceLastJump = 0;
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        private void ChargeWindupBehavior(Player target)
        {
            NPC.velocity.X *= 0.9f;
            
            // Update charge target to track player - BETTER TRACKING
            chargeTarget = target.Center;
            
            // Charge telegraph - FASTER
            if (Timer % 3 == 0)
            {
                Vector2 telegraphDir = (chargeTarget - NPC.Center).SafeNormalize(Vector2.UnitX);
                for (int i = 0; i < 4; i++)
                {
                    Vector2 pos = NPC.Center + telegraphDir * (i * 35);
                    CustomParticles.GenericFlare(pos, EnigmaGreen * 0.7f, 0.35f, 12);
                }
                // Add eye telegraph
                CustomParticles.EnigmaEyeGaze(NPC.Center + telegraphDir * 60f, EnigmaGreen, 0.5f, telegraphDir);
            }
            
            // SHORTER windup
            if (Timer >= 20)
            {
                // Execute charge - update target one more time
                chargeTarget = target.Center;
                Vector2 chargeDir = (chargeTarget - NPC.Center).SafeNormalize(Vector2.UnitX);
                float currentChargeSpeed = isEnraged ? chargeSpeed * 1.4f : chargeSpeed;
                NPC.velocity = chargeDir * currentChargeSpeed;
                
                SoundEngine.PlaySound(SoundID.Roar with { Pitch = 0.5f, Volume = 0.8f }, NPC.Center);
                State = ActionState.Charging;
                Timer = 0;
            }
        }
        
        private void ChargingBehavior(Player target)
        {
            // Charge trail - MORE particles, MORE aggressive
            if (Timer % 2 == 0)
            {
                CustomParticles.GenericFlare(NPC.Center, EnigmaPurple, 0.7f, 15);
                CustomParticles.GenericGlow(NPC.Center, EnigmaGreen, 0.6f, 20);
                CustomParticles.EnigmaEyeGaze(NPC.Center + Main.rand.NextVector2Circular(30, 30), 
                    EnigmaPurple * 0.7f, 0.35f, NPC.velocity.SafeNormalize(Vector2.UnitX));
            }
            
            // AGGRESSIVE course correction during charge - BETTER TRACKING
            if (Timer % 5 == 0)
            {
                Vector2 toTarget = (target.Center - NPC.Center).SafeNormalize(NPC.velocity.SafeNormalize(Vector2.UnitX));
                float correctionStrength = isEnraged ? 0.20f : 0.12f;
                NPC.velocity = Vector2.Lerp(NPC.velocity.SafeNormalize(Vector2.UnitX), toTarget, correctionStrength) * NPC.velocity.Length();
            }
            
            // LONGER charge duration for more pressure
            if (Timer >= 65 || NPC.velocity.Length() < 4f)
            {
                NPC.velocity *= 0.3f;
                State = ActionState.Crawling;
                Timer = 0;
                AttackCooldown = isEnraged ? 20 : 30;
            }
        }
        
        #endregion
        
        #region Attack Selection
        
        private void SelectNextAction(Player target)
        {
            attacksSinceLastJump++;
            
            // === ANTI-AIR PRIORITY - Punish hovering players FIRST ===
            float heightDiff = NPC.Center.Y - target.Center.Y;
            if (playerAboveTimer >= AntiAirThreshold && antiAirAttackCooldown <= 0 && heightDiff > AntiAirHeightThreshold)
            {
                // Player has been hovering too long - USE ANTI-AIR ATTACK
                playerAboveTimer = 0;
                antiAirAttackCooldown = 180; // 3 second cooldown between anti-air attacks
                
                // Select anti-air attack based on mood
                int antiAirRoll = Main.rand.Next(100);
                
                if (currentMood == BossMood.VoidRevelation)
                {
                    // Most aggressive anti-air in final phase
                    if (antiAirRoll < 30)
                        State = ActionState.SkyEyeRainWindup;
                    else if (antiAirRoll < 55)
                        State = ActionState.RealityLeapWindup;
                    else if (antiAirRoll < 80)
                        State = ActionState.GlyphPillarsWindup;
                    else
                        State = ActionState.CeilingWebWindup;
                }
                else if (currentMood == BossMood.Obsession)
                {
                    // Medium aggression anti-air
                    if (antiAirRoll < 40)
                        State = ActionState.SkyEyeRainWindup;
                    else if (antiAirRoll < 70)
                        State = ActionState.GlyphPillarsWindup;
                    else
                        State = ActionState.CeilingWebWindup;
                }
                else
                {
                    // Basic anti-air in Curiosity phase
                    if (antiAirRoll < 50)
                        State = ActionState.CeilingWebWindup;
                    else
                        State = ActionState.GlyphPillarsWindup;
                }
                
                Timer = 0;
                
                SoundEngine.PlaySound(SoundID.Roar with { Pitch = 0.5f }, NPC.Center);
                return;
            }
            
            // Force jump more frequently for mobility - AGGRESSIVE
            if (attacksSinceLastJump >= 2 && jumpCooldown <= 0 && isGrounded)
            {
                State = ActionState.JumpWindup;
                Timer = 0;
                attacksSinceLastJump = 0;
                return;
            }
            
            // Weighted attack selection based on distance and health
            float distance = Vector2.Distance(NPC.Center, target.Center);
            float healthPercent = (float)NPC.life / NPC.lifeMax;
            
            List<ActionState> availableAttacks = new List<ActionState>();
            
            // === PLAYER ABOVE - Add anti-air attacks to pool even before threshold ===
            if (heightDiff > AntiAirHeightThreshold * 0.7f)
            {
                availableAttacks.Add(ActionState.GlyphPillarsWindup);
                availableAttacks.Add(ActionState.EyeBarrageWindup); // Homing eyes can reach air
                if (healthPercent < 0.6f)
                    availableAttacks.Add(ActionState.SkyEyeRainWindup);
            }
            
            // Close range attacks - PRIORITIZE these when close
            if (distance < 350)
            {
                availableAttacks.Add(ActionState.PounceWindup);
                availableAttacks.Add(ActionState.PounceWindup); // Double weight for pounce
                availableAttacks.Add(ActionState.RealityQuakeWindup);
                availableAttacks.Add(ActionState.GlyphEruptionWindup);
                availableAttacks.Add(ActionState.ChargeWindup); // Can charge at close range too
                chargeTarget = target.Center;
            }
            
            // Medium range - AGGRESSIVE mix of approaches
            if (distance >= 150 && distance < 600)
            {
                availableAttacks.Add(ActionState.WebShotWindup);
                availableAttacks.Add(ActionState.EyeBarrageWindup);
                availableAttacks.Add(ActionState.ChargeWindup);
                availableAttacks.Add(ActionState.ChargeWindup); // Double weight for charge
                chargeTarget = target.Center;
            }
            
            // Long range - CLOSE THE GAP AGGRESSIVELY
            if (distance >= 400)
            {
                availableAttacks.Add(ActionState.VoidWebWindup);
                availableAttacks.Add(ActionState.SwarmWindup);
                availableAttacks.Add(ActionState.ChargeWindup); // Always include charge at range
                availableAttacks.Add(ActionState.ChargeWindup);
                chargeTarget = target.Center;
            }
            
            // Enrage dramatically increases vortex frequency
            if (isEnraged)
            {
                availableAttacks.Add(ActionState.VortexWindup);
                if (Main.rand.NextBool(2))
                    availableAttacks.Add(ActionState.VortexWindup); // More vortex when enraged
            }
            
            // LOW HEALTH PHASE (below 50%) - DESPERATE AGGRESSION
            if (healthPercent < 0.5f)
            {
                // Add more charge and pounce attacks
                availableAttacks.Add(ActionState.PounceWindup);
                availableAttacks.Add(ActionState.ChargeWindup);
                chargeTarget = target.Center;
            }
            
            // CRITICAL PHASE (below 25%) - MAXIMUM AGGRESSION
            if (healthPercent < 0.25f)
            {
                availableAttacks.Add(ActionState.VortexWindup);
                availableAttacks.Add(ActionState.RealityQuakeWindup);
                availableAttacks.Add(ActionState.GlyphEruptionWindup);
            }
            
            // Default if no attacks available
            if (availableAttacks.Count == 0)
            {
                availableAttacks.Add(ActionState.WebShotWindup);
                availableAttacks.Add(ActionState.EyeBarrageWindup);
                availableAttacks.Add(ActionState.ChargeWindup);
                chargeTarget = target.Center;
            }
            
            // Pick random attack, avoiding repeats
            ActionState selectedAttack;
            int attempts = 0;
            do
            {
                selectedAttack = availableAttacks[Main.rand.Next(availableAttacks.Count)];
                attempts++;
            } while ((int)selectedAttack == lastAttackType && attempts < 5 && availableAttacks.Count > 1);
            
            lastAttackType = (int)selectedAttack;
            State = selectedAttack;
            Timer = 0;
            
            // REDUCED COOLDOWNS for aggressive pacing
            // Enraged: 15 ticks (0.25 seconds)
            // Critical (below 25%): 10 ticks
            // Normal: 35 ticks (0.58 seconds)
            if (healthPercent < 0.25f)
                AttackCooldown = 10;
            else if (isEnraged)
                AttackCooldown = 15;
            else
                AttackCooldown = 35;
        }
        
        #endregion
        
        #region Attacks
        
        // Attack 1: Web Shot - Fast projectiles
        // Store committed direction for web shot pattern
        private float webShotCommittedAngle = 0f;
        
        private void WebShotWindup(Player target)
        {
            NPC.velocity.X *= 0.9f;
            
            // === COMMIT DIRECTION AT START OF WINDUP ===
            if (Timer == 1)
            {
                // Use predictive aiming - where player WILL be
                Vector2 predictedPos = target.Center + target.velocity * 12f;
                webShotCommittedAngle = (predictedPos - NPC.Center).ToRotation();
            }
            
            // === TELEGRAPH: Show committed direction ===
            if (Timer % 5 == 0)
            {
                Vector2 telegraphDir = webShotCommittedAngle.ToRotationVector2();
                CustomParticles.GenericFlare(NPC.Center + telegraphDir * 40f, EnigmaPurple, 0.4f + Timer * 0.015f, 15);
            }
            
            if (Timer >= 18)
            {
                State = ActionState.WebShot;
                Timer = 0;
                AttackPhase = 0;
            }
        }
        
        private void WebShotAttack(Player target)
        {
            // MORE shots, FASTER rate - AGGRESSIVE barrage
            int shotsPerBurst = isEnraged ? 10 : 7;
            int shotDelay = isEnraged ? 3 : 5;
            
            if (Timer % shotDelay == 0 && AttackPhase < shotsPerBurst)
            {
                // === FIXED SPREAD PATTERN from committed angle ===
                // Shots spread in fixed pattern, sweeping from left to right
                float spreadOffset = (AttackPhase - (shotsPerBurst - 1) / 2f) * 0.10f;
                float shotAngle = webShotCommittedAngle + spreadOffset;
                Vector2 shootDir = shotAngle.ToRotationVector2();
                
                // Fire multiple projectiles per shot (spread pattern)
                int projectilesPerShot = isEnraged ? 3 : 2;
                for (int p = 0; p < projectilesPerShot; p++)
                {
                    float spreadAngle = shotAngle + (p - (projectilesPerShot - 1) / 2f) * 0.05f;
                    Vector2 spreadDir = spreadAngle.ToRotationVector2();
                    float speed = 14f + p * 2f; // Staggered speeds for wave effect
                    
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Center, spreadDir * speed,
                            ModContent.ProjectileType<EnigmaWebShot>(), NPC.damage / 2, 3f, Main.myPlayer);
                    }
                }
                
                // Shot VFX
                CustomParticles.GenericFlare(NPC.Center, EnigmaGreen, 0.6f, 15);
                SoundEngine.PlaySound(SoundID.Item17 with { Pitch = 0.3f }, NPC.Center);
                
                AttackPhase++;
            }
            
            if (AttackPhase >= shotsPerBurst)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 2: Paradox Pounce - Rapid leap attacks
        private float pounceCommittedAngle = 0f;
        
        private void PounceWindup(Player target)
        {
            NPC.velocity.X *= 0.85f;
            
            // === COMMIT TO POUNCE DIRECTION AT START ===
            if (Timer == 1)
            {
                // Predict where player will be for initial pounce
                pounceTarget = target.Center + target.velocity * 15f;
                pounceCommittedAngle = (pounceTarget - NPC.Center).ToRotation();
                pounceCount = 0;
            }
            
            // === CLEAR TELEGRAPH showing pounce direction ===
            if (Timer % 4 == 0)
            {
                Vector2 telegraphDir = pounceCommittedAngle.ToRotationVector2();
                Vector2 telegraphPos = NPC.Center + telegraphDir * (50f + Timer * 3f);
                CustomParticles.EnigmaEyeGaze(telegraphPos, EnigmaGreen, 0.4f, telegraphDir);
                
                // Line of warning particles
                for (int i = 1; i <= 3; i++)
                {
                    Vector2 linePos = NPC.Center + telegraphDir * (i * 30f);
                    CustomParticles.GenericFlare(linePos, EnigmaPurple * 0.5f, 0.2f, 5);
                }
            }
            
            if (Timer >= 20) // Slightly longer for telegraph visibility
            {
                State = ActionState.Pouncing;
                Timer = 0;
            }
        }
        
        private void PounceAttack(Player target)
        {
            // MORE pounces, FASTER speed - AGGRESSIVE chain-pounce
            int maxPounces = isEnraged ? 7 : 5;
            
            if (Timer == 1 && pounceCount < maxPounces)
            {
                // === POUNCE TOWARD COMMITTED DIRECTION (with prediction) ===
                // Re-predict every pounce for constant threat
                Vector2 predictedPos = target.Center + target.velocity * 8f;
                pounceCommittedAngle = (predictedPos - NPC.Center).ToRotation();
                
                float pounceSpeed = isEnraged ? 32f : 26f;
                
                // Fixed arc trajectory using committed angle
                Vector2 pounceDir = pounceCommittedAngle.ToRotationVector2();
                NPC.velocity.X = pounceDir.X * pounceSpeed * 0.9f;
                NPC.velocity.Y = -14f; // Higher arc upward
                
                // Fire projectiles during pounce for added pressure
                if (pounceCount % 2 == 0 && Main.netMode != NetmodeID.MultiplayerClient)
                {
                    Vector2 shootDir = (target.Center - NPC.Center).SafeNormalize(Vector2.UnitX);
                    Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Center, shootDir * 10f,
                        ModContent.ProjectileType<EnigmaWebShot>(), NPC.damage / 3, 2f, Main.myPlayer);
                }
                
                SoundEngine.PlaySound(SoundID.Item24 with { Pitch = 0.2f }, NPC.Center);
                pounceCount++;
            }
            
            // Trail - MORE particles
            if (Timer % 2 == 0)
            {
                CustomParticles.GenericFlare(NPC.Center, EnigmaPurple, 0.5f, 12);
                CustomParticles.EnigmaEyeGaze(NPC.Center + Main.rand.NextVector2Circular(20, 20), 
                    EnigmaGreen * 0.6f, 0.3f, NPC.velocity.SafeNormalize(Vector2.UnitX));
            }
            
            // Check landing for next pounce - FASTER recovery
            if (isGrounded && Timer > 10)
            {
                // Landing impact
                EroicaScreenShake.SmallShake(NPC.Center);
                UnifiedVFX.EnigmaVariations.Impact(NPC.Bottom, 0.7f);
                
                if (pounceCount < maxPounces)
                {
                    Timer = 0; // Reset for next pounce immediately
                }
                else
                {
                    State = ActionState.Crawling;
                    Timer = 0;
                }
            }
            
            // Timeout - shorter
            if (Timer > 70)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 3: Glyph Eruption - Ground AOE - MORE DANGEROUS
        private void GlyphEruptionWindup(Player target)
        {
            NPC.velocity.X *= 0.9f;
            
            // Ground glyph telegraph - FASTER
            if (Timer % 6 == 0)
            {
                float radius = 150f + Timer * 3f;
                CustomParticles.GlyphCircle(NPC.Bottom, EnigmaPurple * 0.6f, 6, radius, 0.07f);
            }
            
            // SHORTER windup
            if (Timer >= 30)
            {
                State = ActionState.GlyphEruption;
                Timer = 0;
            }
        }
        
        private void GlyphEruptionAttack(Player target)
        {
            if (Timer == 1)
            {
                // === PATTERN-BASED ERUPTION - MUCH MORE PROJECTILES ===
                // Multiple staggered wave patterns with tight gaps
                EroicaScreenShake.MediumShake(NPC.Center);
                
                int waves = isEnraged ? 8 : 6;
                for (int wave = 0; wave < waves; wave++)
                {
                    float radius = 60f + wave * 55f;
                    int projectiles = 14 + wave * 4;
                    
                    // === CREATE SMALLER GAPS IN THE PATTERN ===
                    // Skip only 1 projectile per wave - tight pattern
                    HashSet<int> skipIndices = new HashSet<int>();
                    int gapStart = (wave * 3) % projectiles; // Gap position rotates each wave
                    skipIndices.Add(gapStart);
                    
                    for (int i = 0; i < projectiles; i++)
                    {
                        // Skip gap positions
                        if (skipIndices.Contains(i)) continue;
                        
                        float angle = MathHelper.TwoPi * i / projectiles;
                        Vector2 pos = NPC.Bottom + angle.ToRotationVector2() * radius;
                        
                        // === FIXED UPWARD VELOCITY with slight outward spread ===
                        // NOT aimed at player - predictable pattern
                        float upSpeed = 10f + wave * 2.5f;
                        float outwardSpeed = 1.5f + wave * 0.6f;
                        Vector2 vel = new Vector2(angle.ToRotationVector2().X * outwardSpeed, -upSpeed);
                        
                        if (Main.netMode != NetmodeID.MultiplayerClient)
                        {
                            Projectile.NewProjectile(NPC.GetSource_FromAI(), pos, vel,
                                ModContent.ProjectileType<EnigmaGlyphProjectile>(), NPC.damage / 3, 2f, Main.myPlayer);
                        }
                    }
                }
                
                // VFX - enhanced
                UnifiedVFX.EnigmaVariations.Explosion(NPC.Bottom, 2.2f);
                CustomParticles.GlyphBurst(NPC.Bottom, EnigmaGreen, 30, 12f);
                CustomParticles.EnigmaEyeExplosion(NPC.Center, EnigmaPurple, 6, 6f);
                SoundEngine.PlaySound(SoundID.Item122 with { Pitch = -0.2f }, NPC.Center);
            }
            
            if (Timer >= 15)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 4: Eye Barrage - Multiple homing eyes
        private void EyeBarrageWindup(Player target)
        {
            NPC.velocity.X *= 0.9f;
            
            // Eyes gathering
            if (Timer % 8 == 0)
            {
                float angle = Main.rand.NextFloat() * MathHelper.TwoPi;
                Vector2 eyePos = NPC.Center + angle.ToRotationVector2() * 100f;
                CustomParticles.EnigmaEyeGaze(eyePos, EnigmaGreen, 0.3f + Timer * 0.005f, (NPC.Center - eyePos).SafeNormalize(Vector2.UnitX));
            }
            
            if (Timer >= 40)
            {
                State = ActionState.EyeBarrage;
                Timer = 0;
                AttackPhase = 0;
            }
        }
        
        private void EyeBarrageAttack(Player target)
        {
            // MANY more eyes, FASTER spawn rate - overwhelming barrage
            int totalEyes = isEnraged ? 14 : 10;
            int eyeDelay = isEnraged ? 4 : 6;
            
            if (Timer % eyeDelay == 0 && AttackPhase < totalEyes)
            {
                // === FIXED SPAWN PATTERN ===
                // Eyes spawn in predictable ring positions - multiple at once
                int eyesThisBurst = isEnraged ? 2 : 1;
                for (int e = 0; e < eyesThisBurst; e++)
                {
                    int eyeIndex = (int)AttackPhase + e;
                    if (eyeIndex >= totalEyes) break;
                    
                    float angle = MathHelper.TwoPi * eyeIndex / totalEyes;
                    Vector2 spawnPos = NPC.Center + angle.ToRotationVector2() * 60f;
                    
                    // === INITIAL VELOCITY: Fixed outward direction (not toward player) ===
                    // Eyes will home AFTER spawning, but initial direction is predictable
                    Vector2 vel = angle.ToRotationVector2() * 8f;
                    
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), spawnPos, vel,
                            ModContent.ProjectileType<EnigmaHomingEye>(), NPC.damage / 3, 2f, Main.myPlayer, target.whoAmI);
                    }
                    
                    // Spawn VFX
                    CustomParticles.EnigmaEyeGaze(spawnPos, EnigmaGreen, 0.5f, vel.SafeNormalize(Vector2.UnitX));
                    SoundEngine.PlaySound(SoundID.Item8 with { Pitch = 0.4f, Volume = 0.5f }, spawnPos);
                }
                
                // === TELEGRAPH: Show next spawn positions ===
                int nextIndex = (int)AttackPhase + eyesThisBurst;
                if (nextIndex < totalEyes)
                {
                    float nextAngle = MathHelper.TwoPi * nextIndex / totalEyes;
                    Vector2 nextPos = NPC.Center + nextAngle.ToRotationVector2() * 60f;
                    CustomParticles.GenericFlare(nextPos, Color.Yellow * 0.4f, 0.3f, eyeDelay - 2);
                }
                
                AttackPhase += eyesThisBurst;
            }
            
            if (AttackPhase >= totalEyes && Timer > totalEyes * eyeDelay / 2 + 15)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 5: Void Web - Creates damaging web pattern
        private void VoidWebWindup(Player target)
        {
            NPC.velocity.X *= 0.9f;
            
            if (Timer % 15 == 0)
            {
                CustomParticles.GlyphCircle(NPC.Center, EnigmaPurple, 4, 80f + Timer, 0.08f);
            }
            
            if (Timer >= 45)
            {
                State = ActionState.VoidWeb;
                Timer = 0;
            }
        }
        
        private void VoidWebAttack(Player target)
        {
            if (Timer == 1)
            {
                // Create web pattern projectiles - MORE lines, LARGER radius
                int webLines = isEnraged ? 18 : 14;
                float webRadius = 550f;
                
                for (int i = 0; i < webLines; i++)
                {
                    float angle = MathHelper.TwoPi * i / webLines;
                    Vector2 endPos = NPC.Center + angle.ToRotationVector2() * webRadius;
                    
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Center, Vector2.Zero,
                            ModContent.ProjectileType<EnigmaVoidWeb>(), NPC.damage / 4, 0f, Main.myPlayer, 
                            angle, webRadius);
                    }
                }
                
                // VFX - enhanced
                UnifiedVFX.EnigmaVariations.Impact(NPC.Center, 1.5f);
                CustomParticles.GlyphBurst(NPC.Center, EnigmaGreen, 12, 8f);
                SoundEngine.PlaySound(SoundID.Item17 with { Pitch = -0.3f }, NPC.Center);
            }
            
            // Fire additional projectiles during web phase
            if (Timer % 20 == 10 && Timer < 50)
            {
                Vector2 shootDir = (target.Center - NPC.Center).SafeNormalize(Vector2.UnitX);
                if (Main.netMode != NetmodeID.MultiplayerClient)
                {
                    Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Center, shootDir * 12f,
                        ModContent.ProjectileType<EnigmaWebShot>(), NPC.damage / 3, 2f, Main.myPlayer);
                }
                CustomParticles.GenericFlare(NPC.Center, EnigmaGreen, 0.5f, 12);
            }
            
            if (Timer >= 50)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 6: Reality Quake - Ground slam
        private void RealityQuakeWindup(Player target)
        {
            NPC.velocity.X *= 0.85f;
            
            // Charging particles
            float chargeProgress = Timer / 40f;
            if (Timer % 5 == 0)
            {
                CustomParticles.GenericFlare(NPC.Bottom, EnigmaGreen, 0.3f + chargeProgress * 0.5f, 15);
                CustomParticles.GlyphBurst(NPC.Bottom, EnigmaPurple, 2, 1f + chargeProgress * 2f);
            }
            
            if (Timer >= 40)
            {
                State = ActionState.RealityQuake;
                Timer = 0;
            }
        }
        
        private void RealityQuakeAttack(Player target)
        {
            if (Timer == 1)
            {
                // Ground slam! - MASSIVE AREA ATTACK
                EroicaScreenShake.LargeShake(NPC.Center);
                
                // MORE Shockwaves - faster and more numerous
                int waves = isEnraged ? 8 : 6;
                for (int wave = 0; wave < waves; wave++)
                {
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        // Left shockwave - faster
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Bottom - new Vector2(20, 0), new Vector2(-12f - wave * 2.5f, 0),
                            ModContent.ProjectileType<EnigmaShockwave>(), NPC.damage / 2, 5f, Main.myPlayer, wave * 5);
                        // Right shockwave - faster
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Bottom + new Vector2(20, 0), new Vector2(12f + wave * 2.5f, 0),
                            ModContent.ProjectileType<EnigmaShockwave>(), NPC.damage / 2, 5f, Main.myPlayer, wave * 5);
                    }
                }
                
                // Also spawn glyph projectiles upward in a pattern
                for (int i = 0; i < 8; i++)
                {
                    float angle = MathHelper.PiOver4 + MathHelper.Pi * i / 8f;
                    Vector2 vel = angle.ToRotationVector2() * (8f + i);
                    
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Center, vel,
                            ModContent.ProjectileType<EnigmaGlyphProjectile>(), NPC.damage / 3, 2f, Main.myPlayer);
                    }
                }
                
                // Massive impact VFX - enhanced
                UnifiedVFX.EnigmaVariations.Explosion(NPC.Bottom, 2.5f);
                CustomParticles.EnigmaEyeExplosion(NPC.Center, EnigmaGreen, 10, 7f);
                CustomParticles.GlyphBurst(NPC.Bottom, EnigmaPurple, 15, 10f);
                FateRealityDistortion.TriggerInversionPulse(8);
                
                SoundEngine.PlaySound(SoundID.Item14 with { Pitch = -0.5f, Volume = 1.2f }, NPC.Center);
            }
            
            if (Timer >= 30)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 7: Enigma Swarm - Spawn mini spiders
        private void SwarmWindup(Player target)
        {
            NPC.velocity.X *= 0.9f;
            
            if (Timer % 10 == 0)
            {
                CustomParticles.EnigmaEyeFormation(NPC.Center, EnigmaPurple * 0.5f, 3, 50f + Timer);
            }
            
            if (Timer >= 35)
            {
                State = ActionState.Swarm;
                Timer = 0;
            }
        }
        
        private void SwarmAttack(Player target)
        {
            if (Timer == 1)
            {
                // Spawn MORE mini spiders
                int spawnCount = isEnraged ? 10 : 7;
                
                for (int i = 0; i < spawnCount; i++)
                {
                    float angle = MathHelper.TwoPi * i / spawnCount;
                    Vector2 spawnPos = NPC.Center + angle.ToRotationVector2() * 80f;
                    
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        int npcIndex = NPC.NewNPC(NPC.GetSource_FromAI(), (int)spawnPos.X, (int)spawnPos.Y,
                            ModContent.NPCType<EnigmaMiniSpider>(), 0, NPC.whoAmI);
                    }
                    
                    // Spawn VFX
                    UnifiedVFX.EnigmaVariations.Impact(spawnPos, 0.6f);
                }
                
                SoundEngine.PlaySound(SoundID.Zombie103 with { Pitch = 0.3f }, NPC.Center);
            }
            
            if (Timer >= 20)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 8: Mystery Vortex - Pull player while attacking
        private void VortexWindup(Player target)
        {
            NPC.velocity.X *= 0.85f;
            
            // Vortex building - KEEP SPINNING throughout windup
            float chargeProgress = Timer / 50f;
            
            // Continuous spinning vortex effect
            if (Timer % 3 == 0)
            {
                float innerRadius = 60f - chargeProgress * 20f;
                float outerRadius = 100f - chargeProgress * 30f;
                
                // Inner ring - spins faster
                for (int i = 0; i < 6; i++)
                {
                    float angle = MathHelper.TwoPi * i / 6f + Timer * 0.15f;
                    Vector2 pos = NPC.Center + angle.ToRotationVector2() * innerRadius;
                    Color innerColor = Color.Lerp(EnigmaPurple, EnigmaGreen, chargeProgress);
                    CustomParticles.GenericFlare(pos, innerColor, 0.35f + chargeProgress * 0.2f, 12);
                }
                
                // Outer ring - spins opposite direction
                for (int i = 0; i < 4; i++)
                {
                    float angle = MathHelper.TwoPi * i / 4f - Timer * 0.1f;
                    Vector2 pos = NPC.Center + angle.ToRotationVector2() * outerRadius;
                    CustomParticles.GenericFlare(pos, EnigmaPurple, 0.4f, 15);
                }
            }
            
            // Glyph circle spins during charge
            if (Timer % 10 == 0)
            {
                CustomParticles.GlyphCircle(NPC.Center, EnigmaPurple * (0.5f + chargeProgress * 0.5f), 4, 80f - chargeProgress * 30f, 0.1f + chargeProgress * 0.1f);
            }
            
            // Central pulsing core
            if (Timer % 6 == 0)
            {
                CustomParticles.GenericFlare(NPC.Center, EnigmaGreen * chargeProgress, 0.5f + chargeProgress * 0.3f, 15);
            }
            
            if (Timer >= 50)
            {
                State = ActionState.Vortex;
                Timer = 0;
            }
        }
        
        private void VortexAttack(Player target)
        {
            NPC.velocity.X *= 0.95f;
            
            // Pull player toward boss - STRONGER pull
            float pullStrength = 0.7f + (isEnraged ? 0.5f : 0f);
            Vector2 pullDir = (NPC.Center - target.Center).SafeNormalize(Vector2.Zero);
            target.velocity += pullDir * pullStrength;
            
            // Vortex visuals - CONTINUOUS SPINNING throughout attack
            // Multi-layer spinning vortex
            if (Timer % 2 == 0)
            {
                // Inner layer - fast spin
                for (int i = 0; i < 4; i++)
                {
                    float innerAngle = Timer * 0.2f + MathHelper.TwoPi * i / 4f;
                    float innerRadius = 40f + (float)Math.Sin(Timer * 0.1f) * 10f;
                    Vector2 innerPos = NPC.Center + innerAngle.ToRotationVector2() * innerRadius;
                    Color innerColor = Color.Lerp(EnigmaGreen, EnigmaPurple, (float)i / 4f);
                    CustomParticles.GenericFlare(innerPos, innerColor, 0.4f, 10);
                }
                
                // Middle layer - medium spin opposite direction
                for (int i = 0; i < 6; i++)
                {
                    float midAngle = -Timer * 0.12f + MathHelper.TwoPi * i / 6f;
                    float midRadius = 80f + (float)Math.Sin(Timer * 0.08f + i) * 15f;
                    Vector2 midPos = NPC.Center + midAngle.ToRotationVector2() * midRadius;
                    Color midColor = Color.Lerp(EnigmaPurple, EnigmaGreen, (Timer % 30) / 30f);
                    CustomParticles.GenericGlow(midPos, midColor, 0.35f, 15);
                }
                
                // Outer layer - slow spin
                float outerAngle = Timer * 0.08f;
                float outerRadius = 120f - (Timer % 60) * 1.5f;
                Vector2 outerPos = NPC.Center + outerAngle.ToRotationVector2() * outerRadius;
                CustomParticles.GenericGlow(outerPos, EnigmaPurple * 0.7f, 0.3f, 20);
            }
            
            // Glyph circle continuously spinning
            if (Timer % 8 == 0)
            {
                CustomParticles.GlyphCircle(NPC.Center, EnigmaPurple, 6, 100f - (Timer % 40), 0.12f);
            }
            
            // Shoot MORE during vortex - FASTER fire rate, multiple projectiles
            if (Timer % 12 == 6)
            {
                int projectiles = isEnraged ? 4 : 3;
                for (int p = 0; p < projectiles; p++)
                {
                    float spreadAngle = (p - (projectiles - 1) / 2f) * 0.2f;
                    Vector2 shootDir = ((target.Center - NPC.Center).ToRotation() + spreadAngle).ToRotationVector2();
                    
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Center, shootDir * 14f,
                            ModContent.ProjectileType<EnigmaWebShot>(), NPC.damage / 3, 2f, Main.myPlayer);
                    }
                }
                
                CustomParticles.GenericFlare(NPC.Center, EnigmaGreen, 0.6f, 12);
                SoundEngine.PlaySound(SoundID.Item17 with { Pitch = 0.2f, Volume = 0.7f }, NPC.Center);
            }
            
            // LONGER vortex duration for more pressure
            if (Timer >= 160)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // ============================================
        // === ANTI-AIR ATTACKS - THE SKY IS NOT SAFE ===
        // ============================================
        
        // Attack 9: Ceiling Web - Creates a web ceiling that falls and traps
        private void CeilingWebWindup(Player target)
        {
            NPC.velocity.X *= 0.9f;
            
            // Eyes look up menacingly
            if (Timer % 6 == 0)
            {
                Vector2 lookUp = new Vector2(0, -1);
                CustomParticles.EnigmaEyeGaze(NPC.Center + new Vector2(Main.rand.NextFloat(-30, 30), -50), 
                    EnigmaGreen, 0.5f + Timer * 0.01f, lookUp);
                    
                // Glyph warning at ceiling level
                Vector2 ceilingPos = new Vector2(target.Center.X + Main.rand.NextFloat(-100, 100), NPC.Center.Y - 300);
                CustomParticles.Glyph(ceilingPos, EnigmaPurple * 0.6f, 0.3f, -1);
            }
            
            // Rising void energy
            if (Timer % 4 == 0)
            {
                Vector2 risePos = NPC.Center + new Vector2(Main.rand.NextFloat(-40, 40), 0);
                CustomParticles.GenericGlow(risePos, EnigmaPurple, 0.4f, 20);
            }
            
            if (Timer >= 35)
            {
                State = ActionState.CeilingWeb;
                Timer = 0;
                AttackPhase = 0;
            }
        }
        
        private void CeilingWebAttack(Player target)
        {
            // Spawn web lines from above that fall down
            int webCount = isEnraged ? 12 : 8;
            int spawnDelay = isEnraged ? 3 : 5;
            
            if (Timer % spawnDelay == 0 && AttackPhase < webCount)
            {
                // Web spawns above player's area
                float xOffset = (AttackPhase - webCount / 2f) * 80f;
                Vector2 spawnPos = new Vector2(target.Center.X + xOffset, NPC.Center.Y - 400);
                
                // Falling web projectile
                if (Main.netMode != NetmodeID.MultiplayerClient)
                {
                    Projectile.NewProjectile(NPC.GetSource_FromAI(), spawnPos, new Vector2(0, 8f),
                        ModContent.ProjectileType<EnigmaWebShot>(), NPC.damage / 3, 2f, Main.myPlayer);
                }
                
                // VFX - web spawning
                CustomParticles.EnigmaEyeGaze(spawnPos, EnigmaGreen, 0.4f, new Vector2(0, 1));
                CustomParticles.GlyphBurst(spawnPos, EnigmaPurple, 3, 2f);
                
                AttackPhase++;
            }
            
            // Extra falling eyes during attack
            if (Timer % 8 == 4)
            {
                Vector2 eyeSpawn = new Vector2(target.Center.X + Main.rand.NextFloat(-150, 150), NPC.Center.Y - 350);
                if (Main.netMode != NetmodeID.MultiplayerClient)
                {
                    Projectile.NewProjectile(NPC.GetSource_FromAI(), eyeSpawn, new Vector2(0, 6f),
                        ModContent.ProjectileType<EnigmaHomingEye>(), NPC.damage / 4, 1f, Main.myPlayer, target.whoAmI);
                }
                CustomParticles.EnigmaEyeGaze(eyeSpawn, EnigmaGreen, 0.5f, new Vector2(0, 1));
            }
            
            if (Timer >= webCount * spawnDelay + 30)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 10: Sky Eye Rain - Eyes rain from the sky targeting player
        private void SkyEyeRainWindup(Player target)
        {
            NPC.velocity.X *= 0.85f;
            
            // Multiple eyes gather above, looking down
            if (Timer % 4 == 0)
            {
                float spread = 200f + Timer * 3f;
                Vector2 skyPos = new Vector2(target.Center.X + Main.rand.NextFloat(-spread, spread), target.Center.Y - 400);
                CustomParticles.EnigmaEyeGaze(skyPos, EnigmaGreen * (0.4f + Timer * 0.015f), 0.4f, new Vector2(0, 1));
            }
            
            // Glyphs circle in the sky - WARNING
            if (Timer % 8 == 0)
            {
                float angle = Timer * 0.1f;
                Vector2 glyphPos = target.Center + new Vector2((float)Math.Cos(angle) * 150, -300 + (float)Math.Sin(angle * 2) * 30);
                CustomParticles.Glyph(glyphPos, EnigmaPurple, 0.5f, -1);
            }
            
            if (Timer >= 50)
            {
                State = ActionState.SkyEyeRain;
                Timer = 0;
                AttackPhase = 0;
            }
        }
        
        private void SkyEyeRainAttack(Player target)
        {
            // Rain of eyes from above
            int eyeWaves = isEnraged ? 8 : 5;
            int waveDelay = isEnraged ? 10 : 15;
            int eyesPerWave = isEnraged ? 6 : 4;
            
            if (Timer % waveDelay == 0 && AttackPhase < eyeWaves)
            {
                // Spawn wave of falling eyes
                for (int i = 0; i < eyesPerWave; i++)
                {
                    float xOffset = (i - eyesPerWave / 2f) * 100f + Main.rand.NextFloat(-30, 30);
                    Vector2 spawnPos = new Vector2(target.Center.X + xOffset, target.Center.Y - 500);
                    
                    // Predict player movement slightly
                    Vector2 predictedTarget = target.Center + target.velocity * 20f;
                    Vector2 toTarget = (predictedTarget - spawnPos).SafeNormalize(new Vector2(0, 1));
                    
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), spawnPos, toTarget * 10f,
                            ModContent.ProjectileType<EnigmaHomingEye>(), NPC.damage / 3, 2f, Main.myPlayer, target.whoAmI);
                    }
                    
                    // VFX
                    CustomParticles.EnigmaEyeGaze(spawnPos, EnigmaGreen, 0.6f, toTarget);
                }
                
                // Sound for each wave
                SoundEngine.PlaySound(SoundID.Item8 with { Pitch = 0.3f, Volume = 0.6f }, target.Center);
                AttackPhase++;
            }
            
            // Ambient falling glyph particles
            if (Timer % 5 == 0)
            {
                Vector2 glyphPos = new Vector2(target.Center.X + Main.rand.NextFloat(-200, 200), target.Center.Y - 400);
                CustomParticles.Glyph(glyphPos, EnigmaPurple * 0.5f, 0.3f, -1);
            }
            
            if (Timer >= eyeWaves * waveDelay + 40)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 11: Reality Leap - Teleport to player's height and attack
        private Vector2 realityLeapTarget = Vector2.Zero;
        
        private void RealityLeapWindup(Player target)
        {
            NPC.velocity *= 0.9f;
            
            // Commit to leap target
            if (Timer == 1)
            {
                realityLeapTarget = target.Center;
            }
            
            // Void energy gathers
            if (Timer % 3 == 0)
            {
                // Particles spiral inward
                float angle = Timer * 0.3f;
                Vector2 spiralPos = NPC.Center + angle.ToRotationVector2() * (60f - Timer);
                CustomParticles.GenericFlare(spiralPos, EnigmaPurple, 0.4f, 12);
                CustomParticles.Glyph(spiralPos, EnigmaGreen * 0.6f, 0.3f, -1);
            }
            
            // Eyes watch player position
            if (Timer % 8 == 0)
            {
                Vector2 lookDir = (target.Center - NPC.Center).SafeNormalize(Vector2.UnitY);
                CustomParticles.EnigmaEyeGaze(NPC.Center + lookDir * 50f, EnigmaGreen, 0.5f, lookDir);
            }
            
            // Telegraph destination
            if (Timer > 20 && Timer % 5 == 0)
            {
                Vector2 destPos = new Vector2(realityLeapTarget.X + (NPC.Center.X > realityLeapTarget.X ? 150 : -150), realityLeapTarget.Y);
                CustomParticles.GlyphCircle(destPos, EnigmaPurple * 0.5f, 4, 40f, 0.1f);
            }
            
            if (Timer >= 40)
            {
                State = ActionState.RealityLeap;
                Timer = 0;
            }
        }
        
        private void RealityLeapAttack(Player target)
        {
            if (Timer == 1)
            {
                // TELEPORT to player's height
                Vector2 destination = new Vector2(
                    realityLeapTarget.X + (NPC.Center.X > realityLeapTarget.X ? 180 : -180),
                    realityLeapTarget.Y
                );
                
                // Departure VFX
                UnifiedVFX.EnigmaVariations.Explosion(NPC.Center, 1.5f);
                CustomParticles.EnigmaEyeExplosion(NPC.Center, EnigmaGreen, 8, 6f);
                CustomParticles.GlyphBurst(NPC.Center, EnigmaPurple, 10, 8f);
                FateRealityDistortion.TriggerInversionPulse(5);
                
                // Move boss
                NPC.Center = destination;
                NPC.velocity = Vector2.Zero;
                
                // Arrival VFX
                UnifiedVFX.EnigmaVariations.Explosion(NPC.Center, 1.8f);
                CustomParticles.EnigmaEyeFormation(NPC.Center, EnigmaGreen, 6, 80f);
                EroicaScreenShake.MediumShake(NPC.Center);
                
                SoundEngine.PlaySound(SoundID.Item8 with { Pitch = -0.3f, Volume = 1.0f }, NPC.Center);
            }
            
            // Immediately pounce toward player
            if (Timer == 10)
            {
                Vector2 pounceDir = (target.Center - NPC.Center).SafeNormalize(Vector2.UnitX);
                float pounceSpeed = isEnraged ? 30f : 24f;
                NPC.velocity = pounceDir * pounceSpeed;
                
                SoundEngine.PlaySound(SoundID.Roar with { Pitch = 0.4f, Volume = 0.8f }, NPC.Center);
            }
            
            // Trail during pounce
            if (Timer > 10 && Timer % 2 == 0)
            {
                CustomParticles.GenericFlare(NPC.Center, EnigmaPurple, 0.5f, 12);
                CustomParticles.EnigmaEyeGaze(NPC.Center, EnigmaGreen * 0.7f, 0.3f, NPC.velocity.SafeNormalize(Vector2.UnitX));
            }
            
            // Fire web shots during aerial approach
            if (Timer > 15 && Timer % 12 == 0)
            {
                Vector2 shootDir = (target.Center - NPC.Center).SafeNormalize(Vector2.UnitX);
                if (Main.netMode != NetmodeID.MultiplayerClient)
                {
                    Projectile.NewProjectile(NPC.GetSource_FromAI(), NPC.Center, shootDir * 12f,
                        ModContent.ProjectileType<EnigmaWebShot>(), NPC.damage / 3, 2f, Main.myPlayer);
                }
                CustomParticles.GenericFlare(NPC.Center, EnigmaGreen, 0.5f, 10);
            }
            
            if (Timer >= 60)
            {
                NPC.velocity *= 0.5f;
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        // Attack 12: Glyph Pillars - Rising columns of glyphs
        private void GlyphPillarsWindup(Player target)
        {
            NPC.velocity.X *= 0.9f;
            
            // Ground glyphs telegraph pillar positions
            if (Timer % 6 == 0)
            {
                int pillarCount = isEnraged ? 6 : 4;
                for (int i = 0; i < pillarCount; i++)
                {
                    float xOffset = (i - pillarCount / 2f) * 120f;
                    Vector2 pillarBase = new Vector2(target.Center.X + xOffset, NPC.Bottom.Y);
                    CustomParticles.Glyph(pillarBase, EnigmaPurple * (0.3f + Timer * 0.02f), 0.4f, -1);
                }
            }
            
            // Central buildup
            if (Timer % 4 == 0)
            {
                CustomParticles.GenericFlare(NPC.Center, EnigmaGreen, 0.3f + Timer * 0.015f, 15);
            }
            
            if (Timer >= 40)
            {
                State = ActionState.GlyphPillars;
                Timer = 0;
                AttackPhase = 0;
            }
        }
        
        private void GlyphPillarsAttack(Player target)
        {
            int pillarCount = isEnraged ? 8 : 5;
            int pillarDelay = isEnraged ? 8 : 12;
            
            if (Timer % pillarDelay == 0 && AttackPhase < pillarCount)
            {
                // Spawn rising pillar of projectiles
                float xOffset = (AttackPhase - pillarCount / 2f) * 100f;
                Vector2 pillarBase = new Vector2(target.Center.X + xOffset, NPC.Bottom.Y);
                
                // Multiple projectiles per pillar rising upward
                int projectilesPerPillar = isEnraged ? 8 : 6;
                for (int j = 0; j < projectilesPerPillar; j++)
                {
                    Vector2 spawnPos = pillarBase - new Vector2(0, j * 60);
                    Vector2 vel = new Vector2(Main.rand.NextFloat(-1f, 1f), -12f - j * 2f);
                    
                    if (Main.netMode != NetmodeID.MultiplayerClient)
                    {
                        Projectile.NewProjectile(NPC.GetSource_FromAI(), spawnPos, vel,
                            ModContent.ProjectileType<EnigmaGlyphProjectile>(), NPC.damage / 3, 2f, Main.myPlayer);
                    }
                }
                
                // VFX for pillar eruption
                CustomParticles.GlyphBurst(pillarBase, EnigmaPurple, 8, 10f);
                CustomParticles.GenericFlare(pillarBase, EnigmaGreen, 0.8f, 20);
                
                // Eyes watch from the pillar
                for (int e = 0; e < 3; e++)
                {
                    Vector2 eyePos = pillarBase - new Vector2(0, 100 + e * 80);
                    CustomParticles.EnigmaEyeGaze(eyePos, EnigmaGreen, 0.5f, new Vector2(0, -1));
                }
                
                SoundEngine.PlaySound(SoundID.Item122 with { Pitch = 0.2f, Volume = 0.7f }, pillarBase);
                AttackPhase++;
            }
            
            // Screen shake for each pillar
            if (Timer % pillarDelay == 0 && AttackPhase <= pillarCount)
            {
                EroicaScreenShake.SmallShake(NPC.Center);
            }
            
            if (Timer >= pillarCount * pillarDelay + 30)
            {
                State = ActionState.Crawling;
                Timer = 0;
            }
        }
        
        #endregion
        
        #region Death Animation
        
        public override bool CheckDead()
        {
            if (State != ActionState.Dying)
            {
                State = ActionState.Dying;
                Timer = 0;
                deathTimer = 0;
                NPC.life = 1;
                NPC.dontTakeDamage = true;
                NPC.velocity = Vector2.Zero;
                return false;
            }
            return true;
        }
        
        private void UpdateDeathAnimation(Player target)
        {
            deathTimer++;
            NPC.velocity *= 0.95f;
            
            float progress = (float)deathTimer / DeathAnimationDuration;
            
            // Phase 1: Convulsions
            if (deathTimer < 180)
            {
                float intensity = deathTimer / 180f;
                
                if (deathTimer % 10 == 0)
                {
                    // Enhanced impact with multi-layer bloom
                    UnifiedVFXBloom.EnigmaVariations.ImpactEnhanced(NPC.Center + Main.rand.NextVector2Circular(50, 30), 0.5f + intensity * 0.5f);
                    EnhancedParticles.BloomFlare(NPC.Center, EnigmaPurple, 0.3f + intensity * 0.3f, 15, 3, 0.8f);
                }
                
                if (deathTimer % 15 == 0)
                {
                    CustomParticles.EnigmaEyeExplosion(NPC.Center, EnigmaGreen, 3, 3f);
                    EnhancedThemedParticles.EnigmaBloomBurstEnhanced(NPC.Center, 0.4f + intensity * 0.3f);
                }
            }
            // Phase 2: Reality fracturing
            else if (deathTimer < 360)
            {
                float intensity = (deathTimer - 180) / 180f;
                
                if (deathTimer % 8 == 0)
                {
                    // Screen shake removed during death animation - only chromatic effect
                    FateRealityDistortion.TriggerChromaticAberration(NPC.Center, 4f + intensity * 6f, 15);
                    // Enhanced fractal burst with bloom
                    EnhancedParticles.BloomFlare(NPC.Center, EnigmaGreen, 0.4f + intensity * 0.4f, 18, 4, 1f);
                }
                
                if (deathTimer % 20 == 0)
                {
                    // Enhanced explosion with multi-layer bloom
                    UnifiedVFXBloom.EnigmaVariations.ExplosionEnhanced(NPC.Center + Main.rand.NextVector2Circular(80, 50), 1f + intensity);
                    CustomParticles.GlyphBurst(NPC.Center, EnigmaPurple, 8, 5f);
                    EnhancedThemedParticles.EnigmaMusicNotesEnhanced(NPC.Center, 4, 40f);
                }
                
                deathFlashIntensity = intensity * 0.5f;
            }
            // Phase 3: Final collapse
            else if (deathTimer == 360)
            {
                Main.NewText("The Hollow Mystery fades into the unknown...", EnigmaGreen);
                
                // === MASSIVE FINAL EXPLOSION WITH FULL BLOOM SPECTACLE ===
                
                // Central white flash with multi-layer bloom
                EnhancedParticles.BloomFlare(NPC.Center, Color.White, 1.5f, 30, 4, 1.2f);
                EnhancedParticles.BloomFlare(NPC.Center, EnigmaGreen, 1.2f, 28, 4, 1f);
                EnhancedParticles.BloomFlare(NPC.Center, EnigmaPurple, 1f, 26, 4, 0.9f);
                
                // Enhanced death explosion
                UnifiedVFXBloom.EnigmaVariations.ExplosionEnhanced(NPC.Center, 3f);
                
                // Eye explosion with enhanced bloom bursts
                CustomParticles.EnigmaEyeExplosion(NPC.Center, EnigmaGreen, 20, 12f);
                CustomParticles.EnigmaEyeFormation(NPC.Center, EnigmaPurple, 12, 150f);
                EnhancedThemedParticles.EnigmaBloomBurstEnhanced(NPC.Center, 2f);
                
                // Glyph explosion with enhanced effects
                CustomParticles.GlyphBurst(NPC.Center, EnigmaPurple, 20, 10f);
                CustomParticles.GlyphCircle(NPC.Center, EnigmaGreen, 16, 200f, 0f);
                
                // Radial bloom flare pattern (Enigma fractal burst)
                for (int i = 0; i < 12; i++)
                {
                    float angle = MathHelper.TwoPi * i / 12f;
                    Vector2 offset = angle.ToRotationVector2() * 60f;
                    float gradientProgress = (float)i / 12f;
                    Color flareColor = Color.Lerp(EnigmaPurple, EnigmaGreen, gradientProgress);
                    EnhancedParticles.BloomFlare(NPC.Center + offset, flareColor, 0.6f, 22, 3, 0.85f);
                }
                
                // Music notes cascade
                EnhancedThemedParticles.EnigmaMusicNotesEnhanced(NPC.Center, 10, 80f);
                
                FateRealityDistortion.TriggerInversionPulse(15);
                FateRealityDistortion.TriggerChromaticAberration(NPC.Center, 12f, 40);
                
                SoundEngine.PlaySound(SoundID.Item122 with { Pitch = -0.5f, Volume = 1.5f }, NPC.Center);
                SoundEngine.PlaySound(SoundID.NPCDeath10 with { Volume = 1.3f }, NPC.Center);
            }
            
            // Actually die
            if (deathTimer >= DeathAnimationDuration)
            {
                NPC.life = 0;
                NPC.HitEffect(0, 9999);
                NPC.checkDead();
            }
        }
        
        #endregion
        
        #region Drops
        
        public override void ModifyNPCLoot(NPCLoot npcLoot)
        {
            // Resonance Energy (always drops)
            npcLoot.Add(ItemDropRule.Common(ModContent.ItemType<EnigmaResonantEnergy>(), 1, 15, 25));
            
            // Harmonic Core (always drops)
            npcLoot.Add(ItemDropRule.Common(ModContent.ItemType<HarmonicCoreOfEnigma>(), 1, 1, 1));
            
            // Weapons - first drop guaranteed (various types)
            npcLoot.Add(ItemDropRule.OneFromOptions(1,
                ModContent.ItemType<VariationsOfTheVoid>(),      // Melee Sword
                ModContent.ItemType<TheUnresolvedCadence>(),     // Melee Broadsword
                ModContent.ItemType<DissonanceOfSecrets>(),      // Magic Staff
                ModContent.ItemType<CipherNocturne>(),           // Magic Beam
                ModContent.ItemType<FugueOfTheUnknown>()));      // Magic Tome
            
            // Second weapon drop 50% chance (remaining types)
            npcLoot.Add(ItemDropRule.OneFromOptions(2,
                ModContent.ItemType<TheWatchingRefrain>(),       // Summon
                ModContent.ItemType<TheSilentMeasure>(),         // Ranged Gun
                ModContent.ItemType<TacetsEnigma>()));
            
            // Treasure bag in expert
            npcLoot.Add(ItemDropRule.BossBag(ModContent.ItemType<EnigmaTreasureBag>()));
        }
        
        #endregion
        
        #region Drawing
        
        public override bool PreDraw(SpriteBatch spriteBatch, Vector2 screenPos, Color drawColor)
        {
            Texture2D texture = TextureAssets.Npc[Type].Value;
            
            // Single PNG - use full texture
            Rectangle sourceRect = new Rectangle(0, 0, texture.Width, texture.Height);
            
            Vector2 drawPos = NPC.Center - screenPos;
            Vector2 origin = new Vector2(texture.Width / 2, texture.Height / 2);
            SpriteEffects effects = NPC.spriteDirection == -1 ? SpriteEffects.FlipHorizontally : SpriteEffects.None;
            
            // Glow effect
            float glowIntensity = eyeGlowIntensity;
            if (State == ActionState.Dying)
                glowIntensity = deathFlashIntensity;
            
            // Draw glow underlay
            if (glowIntensity > 0.1f)
            {
                Color glowColor = EnigmaGreen * glowIntensity * 0.3f;
                spriteBatch.Draw(texture, drawPos, sourceRect, glowColor, 0f, origin, NPC.scale * 1.1f, effects, 0f);
            }
            
            // Main draw
            spriteBatch.Draw(texture, drawPos, sourceRect, drawColor, 0f, origin, NPC.scale, effects, 0f);
            
            // Overlay glow
            if (glowIntensity > 0.2f)
            {
                Color overlayColor = Color.Lerp(EnigmaPurple, EnigmaGreen, (float)Math.Sin(auraPulse) * 0.5f + 0.5f) * glowIntensity * 0.2f;
                spriteBatch.Draw(texture, drawPos, sourceRect, overlayColor, 0f, origin, NPC.scale, effects, 0f);
            }
            
            return false;
        }
        
        public override void FindFrame(int frameHeight)
        {
            frameCounter++;
            
            int speed = FrameSpeed;
            if (State == ActionState.Charging || State == ActionState.Pouncing)
                speed = 3; // Faster animation during attacks
            
            if (frameCounter >= speed)
            {
                frameCounter = 0;
                currentFrame++;
                if (currentFrame >= TotalFrames)
                    currentFrame = 0;
            }
        }
        
        #endregion
    }
}
